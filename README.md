# Core Gallifrey Interpreter Documentation

#### written by Danny Yang

# 1  Repository Overview

## 1.1 Files:
- `main.ml` - the entry point to the project
- `ast.ml` - encodes the AST nodes
- `pprint.ml` - various functions for pretty-printing (AST nodes, values, etc)
- `utils.ml` - an assortment of utility functions that don't directly evaluate an AST node. handles things like checking capabilities and invariants, and also contains the definitions for states and capability sets and various operations on those data structures
- `eval.ml` - functions for evaluating AST nodes
- `parser.mly` and `lexer.mll` - the lexer and parser
- `test.ml` - automated test cases

## 1.2 Makefile:
- `make` - build the interpreter
- `make bisect` - `make test` then `make report`
- `make test` - build the interpreter and run the tests in `test.ml`
- `make clean` - remove the files generated by previous compilations/executions
- `make report` - use a generate bisect/coverage file to generate an HTML report on code coverage

## 1.3 Usage:
1. `make`
2. `./gallifrey <filename>` to run a core Gallifrey source file OR `./gallifrey -test` to run the test cases

# 2 Core Gallifrey

This section describes the version of core Gallifrey that is implemented by this interpreter. Syntactically it has some similarities to IMP, extended with Gallifrey's notion of classes, constructors, functions, `focus`, and `branch`. Arithmetic operations and control flow (if/while) are supported. Definitions and assignments follow the usual scoping rules.

The version of the type system that I implemented is closest to what the type system looked like in October 2019, with some major modifications (making variables immutable, adding an a validity bit for capabilities).

Gallifrey uses capabilities as a way of ensuring memory-safety; they're essentially names that govern memory locations, and there are various rules for generating/using/consuming capabilities. Capabilities can exist in 2 states, valid or invalid. Valid capabilities may be read and assigned over, while invalid capabilities cannot be read. 

Once a capability for a variable is consumed, generally that capability is marked as invalid which renders the value unreadable until the capability is restored by assigning a new value over it. 

Capabilities are tracked using 3 sets K, K' and P, where K represents available capabilities at the start of evaluation and K' and P represent consumed and borrowed capabilities, respectively, at the end of evaluation. For more detail on capabilities, read Matthew's type system document - I omit detail here to avoid repetition, also because this model of capabilities is likely outdated.

## 2.1 Literals:
- integers or booleans (`true` or `false`)
- no object/record literals anymore

## 2.2 Declaration:
- `let x = e1 in e2`
- the type for x does not need to be annotated, and a fresh capability will be generated
- shadowing is only allowed inside the body of a function

## 2.3 Assignment:
- `e1 = e2`
- variables are not mutable anymore, so the LHS of assignments must be a field

The copying/referencing semantics are similar to Java:
- if the RHS is a pointer to a mutable object, then the LHS pointer will point to the same object
- if the RHS is immutable, then the value will be copied to the location pointed at by the LHS

## 2.4 Control Flow:
- `if e1 { e2 } else { e3 }` - behaves like Ocaml's if/else, or ternaries in other languages
- `while e1 { e2 }` - evaluates to unit

## 2.5 Destroy:
- `destroy(e)` destroys (invalidates) the write capability of the value resulting from evaluating `e`

## 2.6 Capof:
- `capof(e)` evaluates to the write capability of the value resulting from evaluating `e` (a variable or field) without consuming it
- result is `T_cap`; values of type `T_cap` must be used immediately and cannot be stored
- this is a special expression used for passing in capability arguments to functions and for debugging

## 2.7 Sleep
- `sleep(n)` sleeps for `n` seconds, where `n` must be an integer literal

## 2.8 Branch
- `branch x1, x2 ... xn { e }` creates a new branch (child thread) and evalutes `e`
- the new evaluation context has the capabilities for the variables `x1` ... `xn`
- those capabilities are lost in the original context
- the value resulting from evaluating `e` is lost, and there is currently no way to recover the capabilities that are given to the branch

## 2.9 Functions
- Core Gallifrey is functional; functions are anonymous but they can be bound to names
- Function syntax is a bit odd; it looks roughly like `fun ( Λ | λ ) -> t { e }` where `t` is the return type and `e` is the body of the function
- parentheses represent groups of arguments; Λ is a big lambda param and λ is a small lambda param; each group of arguments has 0-1 Λ and 0+ λ, with a pipe symbol separating the Λ and λ params
- there is no partial application or optional/default arguments, but it is possible to make a function return another function. The number of arguments is exactly equal to the number of lambdas
- the closure doesn't close over the memory locations and values; when a function is applied the environment used is the context at the time of application. function application is only legal if the closed over store's variables all still have the same types and capabilities in the application context
- the output type of the function is only checked after it is applied and finishes evaluating (this is specific to this interpreter, not the type system)

### 2.9.1 Function Params
There are 3 types of function parameters. The capability annotations are not actual capabilities; they are meta-capabilities. The purpose of the Λ parameters is to take capabilities on function application, which it uses to verify the capabilities of the λ arguments.

- sigma-Λ params are written as `x: c t`. When the function is called it must be passed an object that is focused, and that object must be of type `t`
- kappa-Λ params are written as `c`. When the function is called it must be passed a capability, which is used to replace all meta-capabilities that are governed by this Λ
- λ params are written as `x : c t`. The meta-cap `c` must correspond to one that was previously defined in a Λ parameter. When the function is called it must be passed a value that has type `t` and write capability equal to the real capability that was passed in for `c`

### 2.9.2 Function Syntax and Meta-capabilities
The groupings of params don't really matter; they are parsed into a single list of lambdas, so there are multiple ways to write the same function signature. for example, `(c0 | a : c0 int)` is the same as `(c0 |) (|a : c0 int)`. However, the meta-capabilies must be alpha-equivalent so `(c0|) (c1 | a : c1 int)` is not the same as `(c0|) (c1 | a : c0 int)`. 

Also note that there's no restriction on which meta-caps you can use in a λ as long as it has been defined before. For example, `(c0 | a : c0 int) (c1 | b : c0 int)` is perfectly legal.

The syntax for writing a function type is exactly the same as declaring params; this means that the type also has param names, but those are not checked. thus, the types `(c0 | a : c0 int) -> int` and `(c0 | b : c0 int) -> int ` are the same. However, as above, the meta-capabilies must be alpha-equivalent.

As stated previously, the capability written in function definitions/signatures are actually meta-capabilities, not actual capability values. What this means is that when a Λ argument is provided, the meta-cap `c` is replaced with the actual capability (for sigma-Λ it is the capability of that focused object, for kappa-Λ it is the capability that was passed in). This replacement occurs in the subsequent λ's, unless there is a Λ that defines it.

For example, given a function f with the signature `(c0 | a : c0 int, b : c0 int) (c1 | c : c1 int) (c0 | d : c0 int) -> ...`, it would be applied as follows (assuming we have variables x, y, z declared as integers, with capabilities c.x, c.y, and c.z, respectively): `f(capof(x), x, x, capof(y), y, capof(z), z)`. The capabilities that are checked for in arguments a, b, c, and d are c.x, c.x, c.y, and c.z, respectively.

## 2.10 Objects/Classes
- classes are declared with `class <name> { <field definitions> }`
- classes can optionally extend another class by using the syntax `class <name> extends <name> { ... }`. This inherits the other class's field definitions.
- 2 fields cannot have the same name, and overloading/shadowing a field name from a parent class is not allowed.
- the basic syntax for field definitions is `<name> : <type>`
- optionally, the `mut` and/or `U` keywords can be used before the field name, to mark the field as mutable or unique; they default to immutable/aliasable otherwise.
- field access is done with `.` synax

### 2.10.1 Constructors
Objects cannot be uninitialized, and must be created using constructors. Constructors are functions which are automatically generated based on the class definition and bound to the name of the class.

They have the following signature (taking into account the fields inherited from parent classes):
- 1 kappa-Λ for all aliasable fields (including the ones inherited from a parent class)
- 1 kappa-Λ for each unique field (in order of declaration)
- 1 λ for each field, in order of declaration

```
class C {mut a : int}; 
class D extends C {mut b : int, mut U c: int, mut d : int}; 
```

In the above example, C's constructor would have a signature `(c0 | a: c0 int) -> C`.
and D's constructor would have a signature `(c0 |) (c1 |) (| a: c0 int) (| b: c0 int) (| c: c1 int) (| d: c0 int) -> D`.

## 2.11 Focus

Focus is one of the main features of Gallifrey, it lets users manipulate unique fields of objects without consuming the capability of the original object.

- Outside of focus, using a unique field is the same as using an aliasable field, and the capability is the same capability as the original object.
- Inside of focus, unique fields get unique capabilities, while aliasable fields still use the object's capability.
- Focusing an object (needs to be stored in a variable) is done using `focus x { e }` where object `x` is focused while `e` is evaluated.

Focused objects are placed on the _focus stack_ which contains all the objects that are focused (focus blocks can be nested). 

When an object is focused, the capability for the object is removed from K and placed onto the focus stack. A unique capability is generated for each unique field of the object and placed in K. 

After evaluating `e`, there are 3 possible situations that determine what happens to the focused object's capability:
- if the unique capabilities are all valid and present in P, then they are removed and the original capability gets removed from the focus stack and put into P
- if the unique capabilities are all valid and present in either P or K', then they are removed and the original capability is removed from the focus stack and put into K'
- if not all the unique capabilities are valid, then they are removed and the original capability is removed from the focus stack, explicitly marked invalid, and put into P

# 3 Interpreter Overview

## 3.1 Design Goals:

The goal of this interpreter is to model the semantics of Gallifrey, and to verify that well-typed/well-formed Gallifrey programs have the desired properties at runtime (and that programs which are not well-typed violate those properties). 

The interpreter contains a lot of runtime checks/asserts  at each step of evaluation, so that if an invariant is violated or unexpected behavior occurs there will be a runtime exception. This helps us make sure that programs we expect to evaluate successfully and correctly will do so, and programs we expect to fail will cause a runtime exception.

The runtime checks are designed to be easy to remove; most of them are in the form of assert statements (`g_assert`) or factored out into separate functions.

## 3.2 Runtime State

At runtime the interpreter keeps track of the following things:
- K: list of available capabilities (and whether they are valid). Internally, capabilities are represented as `string * bool`, with the former being the name and the latter being the validity bit. For invariants regarding capabilities, see below.
- Gamma: store mapping variable names and types to locations (implemented as a stack of hash tables for purposes of scoping)
- Sigma: focus stack (functional stack of capability, type, location triplets)
- C: a list of available class names and their field layouts
- Memory: an abstraction for memory locations, implemented as an Int->Value hash table
- in_func: a flag for whether or not the evaluation context is inside a function body (for purposes of banning or allowing shadowing)
- counter: for generating fresh integers to use for memory locations and capability names

There is a double-indirection system with pointers, such that the location for a variable in the store (and the location for a field stored in an object value) is the memory location for the pointer to that value. 

### 3.2.1 Runtime State Examples

The following are examples of programs and what the state/memory/capabilities look like after executing them. Note that the programs are pseudocode for simplicity.

#### Example 1

```
x = 5
y = x
```

```
store: [x -> 0, y -> 2]

memory: [
    // x
    0 -> V_ptr(1), 
    1 -> V_int(5), 

    // y 
    6 -> V_ptr(7)
    7 -> V_int(5)
]

capabilities: [
    c.x: valid
    c.y: valid
]
```

Immutable values are copied, and the capabilities are not consumed when they are used in assignment.

#### Example 2

```
class C {  
    mut a : int 
}
x = C(10)
y = x
```

```
store: [x -> 0, y -> 4]

memory: [
    // x
    0 -> V_ptr(1), 
    1 -> V_obj(C, [a -> 2]), 
    2 -> V_ptr(3), 
    3 -> V_int(10)

    // y 
    4 -> V_ptr(1)
]

capabilities: [
    c.x: invalid
    c.y: valid
]
```

Mutable values are assigned by reference, and the capabilities are consumed by assignment.

#### Example 3

```
class C {  
    mut a : int 
}
x = C(10)
y = x.a
x.a = 3
```

```
store: [x -> 0, y -> 4]

memory: [
    // x
    0 -> V_ptr(1), 
    1 -> V_obj(C, [a -> 2]), 
    2 -> V_ptr(3), 
    3 -> V_int(3)

    // y 
    4 -> V_ptr(5)
    5 -> V_int(10)
]

capabilities: [
    c.x: valid
    c.y: valid
]
```

While the field is mutable, the value contained in it is not, so it is treated as an immutable assignment. 

Note that if the field's contents WERE mutable, then using a field on the RHS of an unfocused assignment WOULD consume the capability for the object (if the assignment is inside focus AND if the field is unique, then only the unique field capability is consumed).

## 3.3 Runtime Checks

In addition to runtime checks specific to each AST node, there is a set of invariants on capabilities that are checked after each evaluation step (the `validate_result` function in `utils.ml`). They are:
- the Top capability (`c_any`) or Bottom capability (`c_none`) cannot be in either K' or P.
- K' and P must be disjoint
- in the union of K' and P, the valid and invalid version of a capability cannot exist simultaneously, and there cannot be any duplicate capabilities (K' and P are set-like w.r.t capability names)
- there is no "capability value" stored in memory

The last invariant means that the result of`capof` is supposed to be used immediately by the function application, and should not be saved anywhere (`let x = capof(y) in ...` would be illegal).

## 3.4 Testing:

There is an automated test suite for the interpreter (`test.ml`), with tests split into 3 types: 
- value (check the returned value)
- success (check that program succeeded evaluating)
- failure (check that program failed at runtime)

Tests are defined with a string of source code that should be run; additionally an expected value must be provided for the value tests. Lexing or parsing errors in any of the tests will cause the test suite itself to fail, and will not be counted as a runtime exception. 

Tests which check for failure only check that an exception occurred, not what type of exception, so it is recommended to pair them with a similar test that will not throw an exception at runtime.

This project uses Bisect for code coverage - currently code coverage for `eval.ml` (the main interpreter file) is roughly ~95%. To generate a code coverage report, run `make bisect` - this runs the test file and outputs a coverage report which can be accessed by opening `coverage/index.html`. The report details the coverage percentage for each file, which can be inspected line-by-line.

Additionally, some of the longer test programs exist in separate source files (`*.g`) for example purposes. They mostly deal with recursion and higher order functions.

The test suite does not check capabilities for the final value that is produced, so when writing test cases that check for whether or not something can be used, actually write an expression that uses the value.

## 3.5 Known Bugs

Precedence for parsing is not defined particularly well, and in general the parser does not fail in all the cases that it should. For example, there are limitations for what can be on the left hand side of an assignment and what can be used for destroy/sleep, but those are checked at runtime by the interpreter.

Example parsing issue: the string `x.w(x) + x.w(x)` gets parsed as `(x.w(x) + x.w)(x)` instead of `(x.w(x)) + (x.w(x))`

Losing capabilities - an earlier iteration of this system had capabilities being dropped completely from K when they are consumed or destroyed, and K' was dropped if the result was mutable. The current system is _supposed_ to mark capabilities as invalid instead of removing them (with the exception of removing unique field capabilities when focus ends) and invalidate everything in K' instead of dropping. There is a runtime check to ensure that no capabilities are ever lost, but it is commented out because there are capabilities being removed at various points in the program (possibly due to K' being dropped). 

General bugs: any failing test cases (~half a dozen at the time of writing). They mainly relate to restoring capabilities from assignment, and improperly invalidating capabilities from objects.

Areas that could use more test coverage: behavior after branching, behavior after focus, multi-layer focusing, interaction between focus, branch, and function calls.
